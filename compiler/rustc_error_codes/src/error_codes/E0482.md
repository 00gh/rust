A lifetime of return value does not outlive the function call.

Erroneous code example:

```compile_fail,E0482
fn prefix<'a>(
    words: impl Iterator<Item = &'a str>
) -> impl Iterator<Item = String> {
    words.map(|v| format!("foo-{}", v))
}
```

To fix this error, make the lifetime of the returned value explicit.

```
fn prefix<'a>(
    words: impl Iterator<Item = &'a str> + 'a
) -> impl Iterator<Item = String> + 'a {
    words.map(|v| format!("foo-{}", v))
}
```

[`impl Trait`] feature in return type have implicit `'static` lifetime
restriction and the type implementing the `Iterator` passed to the function
lives just `'a`, so shorter time.

The solution involves adding lifetime bound to both function argument and
the return value to make sure that the values inside the iterator
are not dropped when the function goes out of the scope.

Alternative solution would be to guarantee that the `Item` references
in the iterator are alive for the whole lifetime of the program.

```
fn prefix(
    words: impl Iterator<Item = &'static str>
) -> impl Iterator<Item = String> {
    words.map(|v| format!("foo-{}", v))
}
```

Similar lifetime problem might arise when returning closures.

Erroneous code example:

```compile_fail,E0482
fn foo(x: &mut Vec<i32>) -> impl FnMut(&mut Vec<i32>) -> &[i32] {
    |y| {
        y.append(x);
        y
    }
}
```

Analogically, solution here is to use explicit return lifetime
and move the ownership of the variable to the closure.

```
fn foo<'a>(x: &'a mut Vec<i32>) -> impl FnMut(&mut Vec<i32>) -> &[i32] + 'a {
    move |y| {
        y.append(x);
        y
    }
}
```

- [`impl Trait`]: https://doc.rust-lang.org/reference/types/impl-trait.html
- [RFC 1951]: https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html
