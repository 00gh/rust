This error occurs when there is insufficient information for the rust compiler to
prove that some time has a long enough lifetime.

Erroneous code example:

```compile_fail,E0311
use std::borrow::BorrowMut;

trait NestedBorrowMut<U, V> {
    fn nested_borrow_mut(&mut self) -> &mut V;
}

impl<T, U, V> NestedBorrowMut<U, V> for T
where
    T: BorrowMut<U>,
    U: BorrowMut<V>, // error: missing lifetime specifier
{
    fn nested_borrow_mut(&mut self) -> &mut V {
        self.borrow_mut().borrow_mut()
    }
}
```

In this example we have a trait that borrows some inner data element of type `V`
from an outer type `T`, through an intermediate type `U`. The compiler is unable to
prove that the livetime of `U` is long enough to support the reference. To fix the
issue we can explicitly add lifetime specifiers to the `NestedBorrowMut` trait, which
link the lifetimes of the various data types and allow the code to compile.

Working implementation of the `NestedBorrowMut` trait:

```
use std::borrow::BorrowMut;

trait NestedBorrowMut<'a, U, V> {
    fn nested_borrow_mut(& 'a mut self) -> &'a mut V;
}

impl<'a, T, U, V> NestedBorrowMut<'a, U, V> for T
where
    T: BorrowMut<U>,
    U: BorrowMut<V> + 'a, // Adding lifetime specifier
{
    fn nested_borrow_mut(&'a mut self) -> &'a mut V {
        self.borrow_mut().borrow_mut()
    }
}
```
