This error occurs when there is an unsatisfied outlives bound involving an
elided region on a generic type parameter or associated type.

Erroneous code example:

```compile_fail,E0311
fn no_restriction<T>(x: &()) -> &() {
    with_restriction::<T>(x)
}

fn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {
    x
}
```

Why doesn't this code compile? It helps to look at the lifetime bounds that are
automatically adding by the compiler. For more details see the Rust
Documentation for Lifetime Elision:
https://doc.rust-lang.org/reference/lifetime-elision.html]

There are two lifetimes being passed into the `no_restriction()` function: one
associated with the generic type `T` parameter and the other with the input
argument `x`. The compiler does not know which of these lifetimes can be
assigned to the output reference, so we get an error.

One way to "fix" this code would be to remove the generic type argument `T`.
In this case, the lifetime elision works because there is a single input
lifetime, which is associated with `x`.

```
fn no_restriction(x: &()) -> &() {
    with_restriction(x)
}

fn with_restriction<'a>(x: &'a ()) -> &'a () {
    x
}
```

The "correct" way to resolve this error is to explicitly tell the compiler
which input lifetime should be assigned to the output. In this case we give
both the generic type `T` parameter and the argument `x` the same lifetime
requirement as the output reference, producing a working version of the code:
```
fn no_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {
    with_restriction::<T>(x)
}

fn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {
    x
}
```
