This error occurs when there is an unsatisfied outlives bound on a generic
type parameter or associated type.

Erroneous code example:

```compile_fail,E0311
use std::borrow::BorrowMut;

trait NestedBorrowMut<U, V> {
    fn nested_borrow_mut(&mut self) -> &mut V;
}

impl<T, U, V> NestedBorrowMut<U, V> for T
where
    T: BorrowMut<U>,
    U: BorrowMut<V>,
{
    fn nested_borrow_mut(&mut self) -> &mut V {
        let u_ref = self.borrow_mut();
        let v_ref = u_ref.borrow_mut();
        v_ref
    }
}
```

Why doesn't this code compile? It helps to look at the lifetime bounds that
the compiler is automatically adding ("Lifetime Ellision", Chapter 10.3 in the
Rust book) to the `nested_borrow_mut` and `borrow_mut` functions. In both cases
the input is a reference to `self`, so the compiler attempts to assign the
the same lifetime to the input and output.

Looking specifically at `nested_borrow_mut`, we see that there are three object
references to keep track of, along with their associated lifetimes:
- `self` (which is a `&mut T`)
- `u_ref` (which is a `&mut U`)
- `v_ref` (which is a `&mut V`)

The `borrow_mut()` method implicitly requires that that the input and output
have the same lifetime bounds. Thus the lines:

```rust
        let u_ref = self.borrow_mut();
        let v_ref = u_ref.borrow_mut();
```

imply that `u_ref` and `self` must share a lifetime bound, and also that
`v_ref` and `u_ref` share a lifetime bound. The problem is that the function
signature for `nested_borrow_mut` only gives the compiler information about the
lifetimes of `self` and `v_ref` -- nothing about `u_ref`.

The way to fix this error is then to explicitly tell the compiler that the
lifetime of `u_ref` is the same as `self` and `v_ref`, which then allows it
to satisfy the two lifetime bound requirements described above.

Here is the working version of the code:
```rust
use std::borrow::BorrowMut;

trait NestedBorrowMut<'a, U, V> {
    fn nested_borrow_mut(&'a mut self) -> &'a mut V;
}

impl<'a, T, U, V> NestedBorrowMut<'a, U, V> for T
where
    T: BorrowMut<U>,
    U: BorrowMut<V> + 'a,
{
    fn nested_borrow_mut(&'a mut self) -> &'a mut V {
        let u_ref = self.borrow_mut();
        let v_ref = u_ref.borrow_mut();
        v_ref
    }
}
```
