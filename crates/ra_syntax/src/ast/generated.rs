// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::{
    ast,
    SyntaxNode, SyntaxNodeRef, AstNode,
    SyntaxKind::*,
};

// ArgList

#[derive(Debug, Clone)]
pub struct ArgListNode(SyntaxNode);

impl ArgListNode {
    pub fn new(ast: ArgList) -> ArgListNode {
        let syntax = ast.syntax().owned();
        ArgListNode(syntax)
    }
    pub fn ast(&self) -> ArgList {
        ArgList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ArgList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ArgList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ARG_LIST => Some(ArgList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ArgList<'a> {
    pub fn args(self) -> impl Iterator<Item = Expr<'a>> + 'a {
        super::children(self)
    }
}

// ArrayExpr

#[derive(Debug, Clone)]
pub struct ArrayExprNode(SyntaxNode);

impl ArrayExprNode {
    pub fn new(ast: ArrayExpr) -> ArrayExprNode {
        let syntax = ast.syntax().owned();
        ArrayExprNode(syntax)
    }
    pub fn ast(&self) -> ArrayExpr {
        ArrayExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ArrayExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ArrayExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ARRAY_EXPR => Some(ArrayExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ArrayExpr<'a> {}

// ArrayType

#[derive(Debug, Clone)]
pub struct ArrayTypeNode(SyntaxNode);

impl ArrayTypeNode {
    pub fn new(ast: ArrayType) -> ArrayTypeNode {
        let syntax = ast.syntax().owned();
        ArrayTypeNode(syntax)
    }
    pub fn ast(&self) -> ArrayType {
        ArrayType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ArrayType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ArrayType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ARRAY_TYPE => Some(ArrayType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ArrayType<'a> {}

// Attr

#[derive(Debug, Clone)]
pub struct AttrNode(SyntaxNode);

impl AttrNode {
    pub fn new(ast: Attr) -> AttrNode {
        let syntax = ast.syntax().owned();
        AttrNode(syntax)
    }
    pub fn ast(&self) -> Attr {
        Attr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Attr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Attr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ATTR => Some(Attr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Attr<'a> {
    pub fn value(self) -> Option<TokenTree<'a>> {
        super::child_opt(self)
    }
}

// BinExpr

#[derive(Debug, Clone)]
pub struct BinExprNode(SyntaxNode);

impl BinExprNode {
    pub fn new(ast: BinExpr) -> BinExprNode {
        let syntax = ast.syntax().owned();
        BinExprNode(syntax)
    }
    pub fn ast(&self) -> BinExpr {
        BinExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct BinExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for BinExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BIN_EXPR => Some(BinExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> BinExpr<'a> {}

// BindPat

#[derive(Debug, Clone)]
pub struct BindPatNode(SyntaxNode);

impl BindPatNode {
    pub fn new(ast: BindPat) -> BindPatNode {
        let syntax = ast.syntax().owned();
        BindPatNode(syntax)
    }
    pub fn ast(&self) -> BindPat {
        BindPat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct BindPat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for BindPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BIND_PAT => Some(BindPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for BindPat<'a> {}
impl<'a> BindPat<'a> {}

// Block

#[derive(Debug, Clone)]
pub struct BlockNode(SyntaxNode);

impl BlockNode {
    pub fn new(ast: Block) -> BlockNode {
        let syntax = ast.syntax().owned();
        BlockNode(syntax)
    }
    pub fn ast(&self) -> Block {
        Block::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Block<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Block<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BLOCK => Some(Block { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Block<'a> {
    pub fn statements(self) -> impl Iterator<Item = Stmt<'a>> + 'a {
        super::children(self)
    }

    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// BlockExpr

#[derive(Debug, Clone)]
pub struct BlockExprNode(SyntaxNode);

impl BlockExprNode {
    pub fn new(ast: BlockExpr) -> BlockExprNode {
        let syntax = ast.syntax().owned();
        BlockExprNode(syntax)
    }
    pub fn ast(&self) -> BlockExpr {
        BlockExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct BlockExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for BlockExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BLOCK_EXPR => Some(BlockExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> BlockExpr<'a> {
    pub fn block(self) -> Option<Block<'a>> {
        super::child_opt(self)
    }
}

// BreakExpr

#[derive(Debug, Clone)]
pub struct BreakExprNode(SyntaxNode);

impl BreakExprNode {
    pub fn new(ast: BreakExpr) -> BreakExprNode {
        let syntax = ast.syntax().owned();
        BreakExprNode(syntax)
    }
    pub fn ast(&self) -> BreakExpr {
        BreakExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct BreakExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for BreakExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BREAK_EXPR => Some(BreakExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> BreakExpr<'a> {}

// CallExpr

#[derive(Debug, Clone)]
pub struct CallExprNode(SyntaxNode);

impl CallExprNode {
    pub fn new(ast: CallExpr) -> CallExprNode {
        let syntax = ast.syntax().owned();
        CallExprNode(syntax)
    }
    pub fn ast(&self) -> CallExpr {
        CallExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct CallExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for CallExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CALL_EXPR => Some(CallExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::ArgListOwner<'a> for CallExpr<'a> {}
impl<'a> CallExpr<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// CastExpr

#[derive(Debug, Clone)]
pub struct CastExprNode(SyntaxNode);

impl CastExprNode {
    pub fn new(ast: CastExpr) -> CastExprNode {
        let syntax = ast.syntax().owned();
        CastExprNode(syntax)
    }
    pub fn ast(&self) -> CastExpr {
        CastExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct CastExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for CastExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CAST_EXPR => Some(CastExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> CastExpr<'a> {}

// Comment

#[derive(Debug, Clone)]
pub struct CommentNode(SyntaxNode);

impl CommentNode {
    pub fn new(ast: Comment) -> CommentNode {
        let syntax = ast.syntax().owned();
        CommentNode(syntax)
    }
    pub fn ast(&self) -> Comment {
        Comment::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Comment<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Comment<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            COMMENT => Some(Comment { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Comment<'a> {}

// Condition

#[derive(Debug, Clone)]
pub struct ConditionNode(SyntaxNode);

impl ConditionNode {
    pub fn new(ast: Condition) -> ConditionNode {
        let syntax = ast.syntax().owned();
        ConditionNode(syntax)
    }
    pub fn ast(&self) -> Condition {
        Condition::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Condition<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Condition<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CONDITION => Some(Condition { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Condition<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }

    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// ConstDef

#[derive(Debug, Clone)]
pub struct ConstDefNode(SyntaxNode);

impl ConstDefNode {
    pub fn new(ast: ConstDef) -> ConstDefNode {
        let syntax = ast.syntax().owned();
        ConstDefNode(syntax)
    }
    pub fn ast(&self) -> ConstDef {
        ConstDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ConstDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ConstDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CONST_DEF => Some(ConstDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for ConstDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for ConstDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for ConstDef<'a> {}
impl<'a> ConstDef<'a> {}

// ContinueExpr

#[derive(Debug, Clone)]
pub struct ContinueExprNode(SyntaxNode);

impl ContinueExprNode {
    pub fn new(ast: ContinueExpr) -> ContinueExprNode {
        let syntax = ast.syntax().owned();
        ContinueExprNode(syntax)
    }
    pub fn ast(&self) -> ContinueExpr {
        ContinueExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ContinueExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ContinueExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CONTINUE_EXPR => Some(ContinueExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ContinueExpr<'a> {}

// DynTraitType

#[derive(Debug, Clone)]
pub struct DynTraitTypeNode(SyntaxNode);

impl DynTraitTypeNode {
    pub fn new(ast: DynTraitType) -> DynTraitTypeNode {
        let syntax = ast.syntax().owned();
        DynTraitTypeNode(syntax)
    }
    pub fn ast(&self) -> DynTraitType {
        DynTraitType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct DynTraitType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for DynTraitType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            DYN_TRAIT_TYPE => Some(DynTraitType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> DynTraitType<'a> {}

// EnumDef

#[derive(Debug, Clone)]
pub struct EnumDefNode(SyntaxNode);

impl EnumDefNode {
    pub fn new(ast: EnumDef) -> EnumDefNode {
        let syntax = ast.syntax().owned();
        EnumDefNode(syntax)
    }
    pub fn ast(&self) -> EnumDef {
        EnumDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct EnumDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for EnumDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ENUM_DEF => Some(EnumDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for EnumDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for EnumDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for EnumDef<'a> {}
impl<'a> EnumDef<'a> {}

// Expr

#[derive(Debug, Clone)]
pub struct ExprNode(SyntaxNode);

impl ExprNode {
    pub fn new(ast: Expr) -> ExprNode {
        let syntax = ast.syntax().owned();
        ExprNode(syntax)
    }
    pub fn ast(&self) -> Expr {
        Expr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub enum Expr<'a> {
    TupleExpr(TupleExpr<'a>),
    ArrayExpr(ArrayExpr<'a>),
    ParenExpr(ParenExpr<'a>),
    PathExpr(PathExpr<'a>),
    LambdaExpr(LambdaExpr<'a>),
    IfExpr(IfExpr<'a>),
    LoopExpr(LoopExpr<'a>),
    ForExpr(ForExpr<'a>),
    WhileExpr(WhileExpr<'a>),
    ContinueExpr(ContinueExpr<'a>),
    BreakExpr(BreakExpr<'a>),
    Label(Label<'a>),
    BlockExpr(BlockExpr<'a>),
    ReturnExpr(ReturnExpr<'a>),
    MatchExpr(MatchExpr<'a>),
    MatchArmList(MatchArmList<'a>),
    MatchArm(MatchArm<'a>),
    MatchGuard(MatchGuard<'a>),
    StructLit(StructLit<'a>),
    NamedFieldList(NamedFieldList<'a>),
    NamedField(NamedField<'a>),
    CallExpr(CallExpr<'a>),
    IndexExpr(IndexExpr<'a>),
    MethodCallExpr(MethodCallExpr<'a>),
    FieldExpr(FieldExpr<'a>),
    TryExpr(TryExpr<'a>),
    CastExpr(CastExpr<'a>),
    RefExpr(RefExpr<'a>),
    PrefixExpr(PrefixExpr<'a>),
    RangeExpr(RangeExpr<'a>),
    BinExpr(BinExpr<'a>),
    Literal(Literal<'a>),
}

impl<'a> AstNode<'a> for Expr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_EXPR => Some(Expr::TupleExpr(TupleExpr { syntax })),
            ARRAY_EXPR => Some(Expr::ArrayExpr(ArrayExpr { syntax })),
            PAREN_EXPR => Some(Expr::ParenExpr(ParenExpr { syntax })),
            PATH_EXPR => Some(Expr::PathExpr(PathExpr { syntax })),
            LAMBDA_EXPR => Some(Expr::LambdaExpr(LambdaExpr { syntax })),
            IF_EXPR => Some(Expr::IfExpr(IfExpr { syntax })),
            LOOP_EXPR => Some(Expr::LoopExpr(LoopExpr { syntax })),
            FOR_EXPR => Some(Expr::ForExpr(ForExpr { syntax })),
            WHILE_EXPR => Some(Expr::WhileExpr(WhileExpr { syntax })),
            CONTINUE_EXPR => Some(Expr::ContinueExpr(ContinueExpr { syntax })),
            BREAK_EXPR => Some(Expr::BreakExpr(BreakExpr { syntax })),
            LABEL => Some(Expr::Label(Label { syntax })),
            BLOCK_EXPR => Some(Expr::BlockExpr(BlockExpr { syntax })),
            RETURN_EXPR => Some(Expr::ReturnExpr(ReturnExpr { syntax })),
            MATCH_EXPR => Some(Expr::MatchExpr(MatchExpr { syntax })),
            MATCH_ARM_LIST => Some(Expr::MatchArmList(MatchArmList { syntax })),
            MATCH_ARM => Some(Expr::MatchArm(MatchArm { syntax })),
            MATCH_GUARD => Some(Expr::MatchGuard(MatchGuard { syntax })),
            STRUCT_LIT => Some(Expr::StructLit(StructLit { syntax })),
            NAMED_FIELD_LIST => Some(Expr::NamedFieldList(NamedFieldList { syntax })),
            NAMED_FIELD => Some(Expr::NamedField(NamedField { syntax })),
            CALL_EXPR => Some(Expr::CallExpr(CallExpr { syntax })),
            INDEX_EXPR => Some(Expr::IndexExpr(IndexExpr { syntax })),
            METHOD_CALL_EXPR => Some(Expr::MethodCallExpr(MethodCallExpr { syntax })),
            FIELD_EXPR => Some(Expr::FieldExpr(FieldExpr { syntax })),
            TRY_EXPR => Some(Expr::TryExpr(TryExpr { syntax })),
            CAST_EXPR => Some(Expr::CastExpr(CastExpr { syntax })),
            REF_EXPR => Some(Expr::RefExpr(RefExpr { syntax })),
            PREFIX_EXPR => Some(Expr::PrefixExpr(PrefixExpr { syntax })),
            RANGE_EXPR => Some(Expr::RangeExpr(RangeExpr { syntax })),
            BIN_EXPR => Some(Expr::BinExpr(BinExpr { syntax })),
            LITERAL => Some(Expr::Literal(Literal { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            Expr::TupleExpr(inner) => inner.syntax(),
            Expr::ArrayExpr(inner) => inner.syntax(),
            Expr::ParenExpr(inner) => inner.syntax(),
            Expr::PathExpr(inner) => inner.syntax(),
            Expr::LambdaExpr(inner) => inner.syntax(),
            Expr::IfExpr(inner) => inner.syntax(),
            Expr::LoopExpr(inner) => inner.syntax(),
            Expr::ForExpr(inner) => inner.syntax(),
            Expr::WhileExpr(inner) => inner.syntax(),
            Expr::ContinueExpr(inner) => inner.syntax(),
            Expr::BreakExpr(inner) => inner.syntax(),
            Expr::Label(inner) => inner.syntax(),
            Expr::BlockExpr(inner) => inner.syntax(),
            Expr::ReturnExpr(inner) => inner.syntax(),
            Expr::MatchExpr(inner) => inner.syntax(),
            Expr::MatchArmList(inner) => inner.syntax(),
            Expr::MatchArm(inner) => inner.syntax(),
            Expr::MatchGuard(inner) => inner.syntax(),
            Expr::StructLit(inner) => inner.syntax(),
            Expr::NamedFieldList(inner) => inner.syntax(),
            Expr::NamedField(inner) => inner.syntax(),
            Expr::CallExpr(inner) => inner.syntax(),
            Expr::IndexExpr(inner) => inner.syntax(),
            Expr::MethodCallExpr(inner) => inner.syntax(),
            Expr::FieldExpr(inner) => inner.syntax(),
            Expr::TryExpr(inner) => inner.syntax(),
            Expr::CastExpr(inner) => inner.syntax(),
            Expr::RefExpr(inner) => inner.syntax(),
            Expr::PrefixExpr(inner) => inner.syntax(),
            Expr::RangeExpr(inner) => inner.syntax(),
            Expr::BinExpr(inner) => inner.syntax(),
            Expr::Literal(inner) => inner.syntax(),
        }
    }
}

impl<'a> Expr<'a> {}

// ExprStmt

#[derive(Debug, Clone)]
pub struct ExprStmtNode(SyntaxNode);

impl ExprStmtNode {
    pub fn new(ast: ExprStmt) -> ExprStmtNode {
        let syntax = ast.syntax().owned();
        ExprStmtNode(syntax)
    }
    pub fn ast(&self) -> ExprStmt {
        ExprStmt::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ExprStmt<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ExprStmt<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            EXPR_STMT => Some(ExprStmt { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ExprStmt<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// ExternCrateItem

#[derive(Debug, Clone)]
pub struct ExternCrateItemNode(SyntaxNode);

impl ExternCrateItemNode {
    pub fn new(ast: ExternCrateItem) -> ExternCrateItemNode {
        let syntax = ast.syntax().owned();
        ExternCrateItemNode(syntax)
    }
    pub fn ast(&self) -> ExternCrateItem {
        ExternCrateItem::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ExternCrateItem<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ExternCrateItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            EXTERN_CRATE_ITEM => Some(ExternCrateItem { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ExternCrateItem<'a> {}

// FieldExpr

#[derive(Debug, Clone)]
pub struct FieldExprNode(SyntaxNode);

impl FieldExprNode {
    pub fn new(ast: FieldExpr) -> FieldExprNode {
        let syntax = ast.syntax().owned();
        FieldExprNode(syntax)
    }
    pub fn ast(&self) -> FieldExpr {
        FieldExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct FieldExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for FieldExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FIELD_EXPR => Some(FieldExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> FieldExpr<'a> {}

// FieldPatList

#[derive(Debug, Clone)]
pub struct FieldPatListNode(SyntaxNode);

impl FieldPatListNode {
    pub fn new(ast: FieldPatList) -> FieldPatListNode {
        let syntax = ast.syntax().owned();
        FieldPatListNode(syntax)
    }
    pub fn ast(&self) -> FieldPatList {
        FieldPatList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct FieldPatList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for FieldPatList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FIELD_PAT_LIST => Some(FieldPatList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> FieldPatList<'a> {}

// FnDef

#[derive(Debug, Clone)]
pub struct FnDefNode(SyntaxNode);

impl FnDefNode {
    pub fn new(ast: FnDef) -> FnDefNode {
        let syntax = ast.syntax().owned();
        FnDefNode(syntax)
    }
    pub fn ast(&self) -> FnDef {
        FnDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct FnDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for FnDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FN_DEF => Some(FnDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for FnDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for FnDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for FnDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for FnDef<'a> {}
impl<'a> FnDef<'a> {
    pub fn param_list(self) -> Option<ParamList<'a>> {
        super::child_opt(self)
    }

    pub fn body(self) -> Option<Block<'a>> {
        super::child_opt(self)
    }

    pub fn ret_type(self) -> Option<RetType<'a>> {
        super::child_opt(self)
    }
}

// FnPointerType

#[derive(Debug, Clone)]
pub struct FnPointerTypeNode(SyntaxNode);

impl FnPointerTypeNode {
    pub fn new(ast: FnPointerType) -> FnPointerTypeNode {
        let syntax = ast.syntax().owned();
        FnPointerTypeNode(syntax)
    }
    pub fn ast(&self) -> FnPointerType {
        FnPointerType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct FnPointerType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for FnPointerType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FN_POINTER_TYPE => Some(FnPointerType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> FnPointerType<'a> {}

// ForExpr

#[derive(Debug, Clone)]
pub struct ForExprNode(SyntaxNode);

impl ForExprNode {
    pub fn new(ast: ForExpr) -> ForExprNode {
        let syntax = ast.syntax().owned();
        ForExprNode(syntax)
    }
    pub fn ast(&self) -> ForExpr {
        ForExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ForExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ForExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FOR_EXPR => Some(ForExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::LoopBodyOwner<'a> for ForExpr<'a> {}
impl<'a> ForExpr<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }

    pub fn iterable(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// ForType

#[derive(Debug, Clone)]
pub struct ForTypeNode(SyntaxNode);

impl ForTypeNode {
    pub fn new(ast: ForType) -> ForTypeNode {
        let syntax = ast.syntax().owned();
        ForTypeNode(syntax)
    }
    pub fn ast(&self) -> ForType {
        ForType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ForType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ForType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FOR_TYPE => Some(ForType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ForType<'a> {}

// IfExpr

#[derive(Debug, Clone)]
pub struct IfExprNode(SyntaxNode);

impl IfExprNode {
    pub fn new(ast: IfExpr) -> IfExprNode {
        let syntax = ast.syntax().owned();
        IfExprNode(syntax)
    }
    pub fn ast(&self) -> IfExpr {
        IfExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct IfExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for IfExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            IF_EXPR => Some(IfExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> IfExpr<'a> {
    pub fn condition(self) -> Option<Condition<'a>> {
        super::child_opt(self)
    }
}

// ImplItem

#[derive(Debug, Clone)]
pub struct ImplItemNode(SyntaxNode);

impl ImplItemNode {
    pub fn new(ast: ImplItem) -> ImplItemNode {
        let syntax = ast.syntax().owned();
        ImplItemNode(syntax)
    }
    pub fn ast(&self) -> ImplItem {
        ImplItem::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ImplItem<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ImplItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            IMPL_ITEM => Some(ImplItem { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ImplItem<'a> {}

// ImplTraitType

#[derive(Debug, Clone)]
pub struct ImplTraitTypeNode(SyntaxNode);

impl ImplTraitTypeNode {
    pub fn new(ast: ImplTraitType) -> ImplTraitTypeNode {
        let syntax = ast.syntax().owned();
        ImplTraitTypeNode(syntax)
    }
    pub fn ast(&self) -> ImplTraitType {
        ImplTraitType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ImplTraitType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ImplTraitType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            IMPL_TRAIT_TYPE => Some(ImplTraitType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ImplTraitType<'a> {}

// IndexExpr

#[derive(Debug, Clone)]
pub struct IndexExprNode(SyntaxNode);

impl IndexExprNode {
    pub fn new(ast: IndexExpr) -> IndexExprNode {
        let syntax = ast.syntax().owned();
        IndexExprNode(syntax)
    }
    pub fn ast(&self) -> IndexExpr {
        IndexExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct IndexExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for IndexExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            INDEX_EXPR => Some(IndexExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> IndexExpr<'a> {}

// ItemList

#[derive(Debug, Clone)]
pub struct ItemListNode(SyntaxNode);

impl ItemListNode {
    pub fn new(ast: ItemList) -> ItemListNode {
        let syntax = ast.syntax().owned();
        ItemListNode(syntax)
    }
    pub fn ast(&self) -> ItemList {
        ItemList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ItemList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ItemList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ITEM_LIST => Some(ItemList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::FnDefOwner<'a> for ItemList<'a> {}
impl<'a> ast::ModuleItemOwner<'a> for ItemList<'a> {}
impl<'a> ItemList<'a> {}

// Label

#[derive(Debug, Clone)]
pub struct LabelNode(SyntaxNode);

impl LabelNode {
    pub fn new(ast: Label) -> LabelNode {
        let syntax = ast.syntax().owned();
        LabelNode(syntax)
    }
    pub fn ast(&self) -> Label {
        Label::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Label<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Label<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LABEL => Some(Label { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Label<'a> {}

// LambdaExpr

#[derive(Debug, Clone)]
pub struct LambdaExprNode(SyntaxNode);

impl LambdaExprNode {
    pub fn new(ast: LambdaExpr) -> LambdaExprNode {
        let syntax = ast.syntax().owned();
        LambdaExprNode(syntax)
    }
    pub fn ast(&self) -> LambdaExpr {
        LambdaExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct LambdaExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for LambdaExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LAMBDA_EXPR => Some(LambdaExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> LambdaExpr<'a> {
    pub fn param_list(self) -> Option<ParamList<'a>> {
        super::child_opt(self)
    }

    pub fn body(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// LetStmt

#[derive(Debug, Clone)]
pub struct LetStmtNode(SyntaxNode);

impl LetStmtNode {
    pub fn new(ast: LetStmt) -> LetStmtNode {
        let syntax = ast.syntax().owned();
        LetStmtNode(syntax)
    }
    pub fn ast(&self) -> LetStmt {
        LetStmt::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct LetStmt<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for LetStmt<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LET_STMT => Some(LetStmt { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> LetStmt<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }

    pub fn initializer(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// Lifetime

#[derive(Debug, Clone)]
pub struct LifetimeNode(SyntaxNode);

impl LifetimeNode {
    pub fn new(ast: Lifetime) -> LifetimeNode {
        let syntax = ast.syntax().owned();
        LifetimeNode(syntax)
    }
    pub fn ast(&self) -> Lifetime {
        Lifetime::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Lifetime<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Lifetime<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LIFETIME => Some(Lifetime { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Lifetime<'a> {}

// LifetimeParam

#[derive(Debug, Clone)]
pub struct LifetimeParamNode(SyntaxNode);

impl LifetimeParamNode {
    pub fn new(ast: LifetimeParam) -> LifetimeParamNode {
        let syntax = ast.syntax().owned();
        LifetimeParamNode(syntax)
    }
    pub fn ast(&self) -> LifetimeParam {
        LifetimeParam::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct LifetimeParam<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for LifetimeParam<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LIFETIME_PARAM => Some(LifetimeParam { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> LifetimeParam<'a> {
    pub fn lifetime(self) -> Option<Lifetime<'a>> {
        super::child_opt(self)
    }
}

// Literal

#[derive(Debug, Clone)]
pub struct LiteralNode(SyntaxNode);

impl LiteralNode {
    pub fn new(ast: Literal) -> LiteralNode {
        let syntax = ast.syntax().owned();
        LiteralNode(syntax)
    }
    pub fn ast(&self) -> Literal {
        Literal::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Literal<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Literal<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LITERAL => Some(Literal { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Literal<'a> {}

// LoopExpr

#[derive(Debug, Clone)]
pub struct LoopExprNode(SyntaxNode);

impl LoopExprNode {
    pub fn new(ast: LoopExpr) -> LoopExprNode {
        let syntax = ast.syntax().owned();
        LoopExprNode(syntax)
    }
    pub fn ast(&self) -> LoopExpr {
        LoopExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct LoopExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for LoopExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LOOP_EXPR => Some(LoopExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::LoopBodyOwner<'a> for LoopExpr<'a> {}
impl<'a> LoopExpr<'a> {}

// MatchArm

#[derive(Debug, Clone)]
pub struct MatchArmNode(SyntaxNode);

impl MatchArmNode {
    pub fn new(ast: MatchArm) -> MatchArmNode {
        let syntax = ast.syntax().owned();
        MatchArmNode(syntax)
    }
    pub fn ast(&self) -> MatchArm {
        MatchArm::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct MatchArm<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for MatchArm<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_ARM => Some(MatchArm { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> MatchArm<'a> {
    pub fn pats(self) -> impl Iterator<Item = Pat<'a>> + 'a {
        super::children(self)
    }

    pub fn guard(self) -> Option<MatchGuard<'a>> {
        super::child_opt(self)
    }

    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// MatchArmList

#[derive(Debug, Clone)]
pub struct MatchArmListNode(SyntaxNode);

impl MatchArmListNode {
    pub fn new(ast: MatchArmList) -> MatchArmListNode {
        let syntax = ast.syntax().owned();
        MatchArmListNode(syntax)
    }
    pub fn ast(&self) -> MatchArmList {
        MatchArmList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct MatchArmList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for MatchArmList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_ARM_LIST => Some(MatchArmList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> MatchArmList<'a> {
    pub fn arms(self) -> impl Iterator<Item = MatchArm<'a>> + 'a {
        super::children(self)
    }
}

// MatchExpr

#[derive(Debug, Clone)]
pub struct MatchExprNode(SyntaxNode);

impl MatchExprNode {
    pub fn new(ast: MatchExpr) -> MatchExprNode {
        let syntax = ast.syntax().owned();
        MatchExprNode(syntax)
    }
    pub fn ast(&self) -> MatchExpr {
        MatchExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct MatchExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for MatchExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_EXPR => Some(MatchExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> MatchExpr<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }

    pub fn match_arm_list(self) -> Option<MatchArmList<'a>> {
        super::child_opt(self)
    }
}

// MatchGuard

#[derive(Debug, Clone)]
pub struct MatchGuardNode(SyntaxNode);

impl MatchGuardNode {
    pub fn new(ast: MatchGuard) -> MatchGuardNode {
        let syntax = ast.syntax().owned();
        MatchGuardNode(syntax)
    }
    pub fn ast(&self) -> MatchGuard {
        MatchGuard::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct MatchGuard<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for MatchGuard<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_GUARD => Some(MatchGuard { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> MatchGuard<'a> {}

// MethodCallExpr

#[derive(Debug, Clone)]
pub struct MethodCallExprNode(SyntaxNode);

impl MethodCallExprNode {
    pub fn new(ast: MethodCallExpr) -> MethodCallExprNode {
        let syntax = ast.syntax().owned();
        MethodCallExprNode(syntax)
    }
    pub fn ast(&self) -> MethodCallExpr {
        MethodCallExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct MethodCallExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for MethodCallExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            METHOD_CALL_EXPR => Some(MethodCallExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::ArgListOwner<'a> for MethodCallExpr<'a> {}
impl<'a> MethodCallExpr<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// Module

#[derive(Debug, Clone)]
pub struct ModuleNode(SyntaxNode);

impl ModuleNode {
    pub fn new(ast: Module) -> ModuleNode {
        let syntax = ast.syntax().owned();
        ModuleNode(syntax)
    }
    pub fn ast(&self) -> Module {
        Module::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Module<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Module<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MODULE => Some(Module { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for Module<'a> {}
impl<'a> ast::AttrsOwner<'a> for Module<'a> {}
impl<'a> Module<'a> {
    pub fn item_list(self) -> Option<ItemList<'a>> {
        super::child_opt(self)
    }
}

// ModuleItem

#[derive(Debug, Clone)]
pub struct ModuleItemNode(SyntaxNode);

impl ModuleItemNode {
    pub fn new(ast: ModuleItem) -> ModuleItemNode {
        let syntax = ast.syntax().owned();
        ModuleItemNode(syntax)
    }
    pub fn ast(&self) -> ModuleItem {
        ModuleItem::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub enum ModuleItem<'a> {
    StructDef(StructDef<'a>),
    EnumDef(EnumDef<'a>),
    FnDef(FnDef<'a>),
    TraitDef(TraitDef<'a>),
    TypeDef(TypeDef<'a>),
    ImplItem(ImplItem<'a>),
    UseItem(UseItem<'a>),
    ExternCrateItem(ExternCrateItem<'a>),
    ConstDef(ConstDef<'a>),
    StaticDef(StaticDef<'a>),
    Module(Module<'a>),
}

impl<'a> AstNode<'a> for ModuleItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_DEF => Some(ModuleItem::StructDef(StructDef { syntax })),
            ENUM_DEF => Some(ModuleItem::EnumDef(EnumDef { syntax })),
            FN_DEF => Some(ModuleItem::FnDef(FnDef { syntax })),
            TRAIT_DEF => Some(ModuleItem::TraitDef(TraitDef { syntax })),
            TYPE_DEF => Some(ModuleItem::TypeDef(TypeDef { syntax })),
            IMPL_ITEM => Some(ModuleItem::ImplItem(ImplItem { syntax })),
            USE_ITEM => Some(ModuleItem::UseItem(UseItem { syntax })),
            EXTERN_CRATE_ITEM => Some(ModuleItem::ExternCrateItem(ExternCrateItem { syntax })),
            CONST_DEF => Some(ModuleItem::ConstDef(ConstDef { syntax })),
            STATIC_DEF => Some(ModuleItem::StaticDef(StaticDef { syntax })),
            MODULE => Some(ModuleItem::Module(Module { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            ModuleItem::StructDef(inner) => inner.syntax(),
            ModuleItem::EnumDef(inner) => inner.syntax(),
            ModuleItem::FnDef(inner) => inner.syntax(),
            ModuleItem::TraitDef(inner) => inner.syntax(),
            ModuleItem::TypeDef(inner) => inner.syntax(),
            ModuleItem::ImplItem(inner) => inner.syntax(),
            ModuleItem::UseItem(inner) => inner.syntax(),
            ModuleItem::ExternCrateItem(inner) => inner.syntax(),
            ModuleItem::ConstDef(inner) => inner.syntax(),
            ModuleItem::StaticDef(inner) => inner.syntax(),
            ModuleItem::Module(inner) => inner.syntax(),
        }
    }
}

impl<'a> ModuleItem<'a> {}

// Name

#[derive(Debug, Clone)]
pub struct NameNode(SyntaxNode);

impl NameNode {
    pub fn new(ast: Name) -> NameNode {
        let syntax = ast.syntax().owned();
        NameNode(syntax)
    }
    pub fn ast(&self) -> Name {
        Name::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Name<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Name<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAME => Some(Name { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Name<'a> {}

// NameRef

#[derive(Debug, Clone)]
pub struct NameRefNode(SyntaxNode);

impl NameRefNode {
    pub fn new(ast: NameRef) -> NameRefNode {
        let syntax = ast.syntax().owned();
        NameRefNode(syntax)
    }
    pub fn ast(&self) -> NameRef {
        NameRef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct NameRef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for NameRef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAME_REF => Some(NameRef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> NameRef<'a> {}

// NamedField

#[derive(Debug, Clone)]
pub struct NamedFieldNode(SyntaxNode);

impl NamedFieldNode {
    pub fn new(ast: NamedField) -> NamedFieldNode {
        let syntax = ast.syntax().owned();
        NamedFieldNode(syntax)
    }
    pub fn ast(&self) -> NamedField {
        NamedField::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct NamedField<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for NamedField<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAMED_FIELD => Some(NamedField { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> NamedField<'a> {}

// NamedFieldDef

#[derive(Debug, Clone)]
pub struct NamedFieldDefNode(SyntaxNode);

impl NamedFieldDefNode {
    pub fn new(ast: NamedFieldDef) -> NamedFieldDefNode {
        let syntax = ast.syntax().owned();
        NamedFieldDefNode(syntax)
    }
    pub fn ast(&self) -> NamedFieldDef {
        NamedFieldDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct NamedFieldDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for NamedFieldDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAMED_FIELD_DEF => Some(NamedFieldDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for NamedFieldDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for NamedFieldDef<'a> {}
impl<'a> NamedFieldDef<'a> {}

// NamedFieldList

#[derive(Debug, Clone)]
pub struct NamedFieldListNode(SyntaxNode);

impl NamedFieldListNode {
    pub fn new(ast: NamedFieldList) -> NamedFieldListNode {
        let syntax = ast.syntax().owned();
        NamedFieldListNode(syntax)
    }
    pub fn ast(&self) -> NamedFieldList {
        NamedFieldList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct NamedFieldList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for NamedFieldList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAMED_FIELD_LIST => Some(NamedFieldList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> NamedFieldList<'a> {}

// NeverType

#[derive(Debug, Clone)]
pub struct NeverTypeNode(SyntaxNode);

impl NeverTypeNode {
    pub fn new(ast: NeverType) -> NeverTypeNode {
        let syntax = ast.syntax().owned();
        NeverTypeNode(syntax)
    }
    pub fn ast(&self) -> NeverType {
        NeverType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct NeverType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for NeverType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NEVER_TYPE => Some(NeverType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> NeverType<'a> {}

// NominalDef

#[derive(Debug, Clone)]
pub struct NominalDefNode(SyntaxNode);

impl NominalDefNode {
    pub fn new(ast: NominalDef) -> NominalDefNode {
        let syntax = ast.syntax().owned();
        NominalDefNode(syntax)
    }
    pub fn ast(&self) -> NominalDef {
        NominalDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub enum NominalDef<'a> {
    StructDef(StructDef<'a>),
    EnumDef(EnumDef<'a>),
}

impl<'a> AstNode<'a> for NominalDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_DEF => Some(NominalDef::StructDef(StructDef { syntax })),
            ENUM_DEF => Some(NominalDef::EnumDef(EnumDef { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            NominalDef::StructDef(inner) => inner.syntax(),
            NominalDef::EnumDef(inner) => inner.syntax(),
        }
    }
}

impl<'a> ast::NameOwner<'a> for NominalDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for NominalDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for NominalDef<'a> {}
impl<'a> NominalDef<'a> {}

// Param

#[derive(Debug, Clone)]
pub struct ParamNode(SyntaxNode);

impl ParamNode {
    pub fn new(ast: Param) -> ParamNode {
        let syntax = ast.syntax().owned();
        ParamNode(syntax)
    }
    pub fn ast(&self) -> Param {
        Param::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Param<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Param<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PARAM => Some(Param { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Param<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }
}

// ParamList

#[derive(Debug, Clone)]
pub struct ParamListNode(SyntaxNode);

impl ParamListNode {
    pub fn new(ast: ParamList) -> ParamListNode {
        let syntax = ast.syntax().owned();
        ParamListNode(syntax)
    }
    pub fn ast(&self) -> ParamList {
        ParamList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ParamList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ParamList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PARAM_LIST => Some(ParamList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ParamList<'a> {
    pub fn params(self) -> impl Iterator<Item = Param<'a>> + 'a {
        super::children(self)
    }

    pub fn self_param(self) -> Option<SelfParam<'a>> {
        super::child_opt(self)
    }
}

// ParenExpr

#[derive(Debug, Clone)]
pub struct ParenExprNode(SyntaxNode);

impl ParenExprNode {
    pub fn new(ast: ParenExpr) -> ParenExprNode {
        let syntax = ast.syntax().owned();
        ParenExprNode(syntax)
    }
    pub fn ast(&self) -> ParenExpr {
        ParenExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ParenExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ParenExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PAREN_EXPR => Some(ParenExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ParenExpr<'a> {}

// ParenType

#[derive(Debug, Clone)]
pub struct ParenTypeNode(SyntaxNode);

impl ParenTypeNode {
    pub fn new(ast: ParenType) -> ParenTypeNode {
        let syntax = ast.syntax().owned();
        ParenTypeNode(syntax)
    }
    pub fn ast(&self) -> ParenType {
        ParenType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ParenType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ParenType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PAREN_TYPE => Some(ParenType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ParenType<'a> {}

// Pat

#[derive(Debug, Clone)]
pub struct PatNode(SyntaxNode);

impl PatNode {
    pub fn new(ast: Pat) -> PatNode {
        let syntax = ast.syntax().owned();
        PatNode(syntax)
    }
    pub fn ast(&self) -> Pat {
        Pat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub enum Pat<'a> {
    RefPat(RefPat<'a>),
    BindPat(BindPat<'a>),
    PlaceholderPat(PlaceholderPat<'a>),
    PathPat(PathPat<'a>),
    StructPat(StructPat<'a>),
    FieldPatList(FieldPatList<'a>),
    TupleStructPat(TupleStructPat<'a>),
    TuplePat(TuplePat<'a>),
    SlicePat(SlicePat<'a>),
    RangePat(RangePat<'a>),
}

impl<'a> AstNode<'a> for Pat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REF_PAT => Some(Pat::RefPat(RefPat { syntax })),
            BIND_PAT => Some(Pat::BindPat(BindPat { syntax })),
            PLACEHOLDER_PAT => Some(Pat::PlaceholderPat(PlaceholderPat { syntax })),
            PATH_PAT => Some(Pat::PathPat(PathPat { syntax })),
            STRUCT_PAT => Some(Pat::StructPat(StructPat { syntax })),
            FIELD_PAT_LIST => Some(Pat::FieldPatList(FieldPatList { syntax })),
            TUPLE_STRUCT_PAT => Some(Pat::TupleStructPat(TupleStructPat { syntax })),
            TUPLE_PAT => Some(Pat::TuplePat(TuplePat { syntax })),
            SLICE_PAT => Some(Pat::SlicePat(SlicePat { syntax })),
            RANGE_PAT => Some(Pat::RangePat(RangePat { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            Pat::RefPat(inner) => inner.syntax(),
            Pat::BindPat(inner) => inner.syntax(),
            Pat::PlaceholderPat(inner) => inner.syntax(),
            Pat::PathPat(inner) => inner.syntax(),
            Pat::StructPat(inner) => inner.syntax(),
            Pat::FieldPatList(inner) => inner.syntax(),
            Pat::TupleStructPat(inner) => inner.syntax(),
            Pat::TuplePat(inner) => inner.syntax(),
            Pat::SlicePat(inner) => inner.syntax(),
            Pat::RangePat(inner) => inner.syntax(),
        }
    }
}

impl<'a> Pat<'a> {}

// Path

#[derive(Debug, Clone)]
pub struct PathNode(SyntaxNode);

impl PathNode {
    pub fn new(ast: Path) -> PathNode {
        let syntax = ast.syntax().owned();
        PathNode(syntax)
    }
    pub fn ast(&self) -> Path {
        Path::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Path<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Path<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH => Some(Path { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Path<'a> {
    pub fn segment(self) -> Option<PathSegment<'a>> {
        super::child_opt(self)
    }

    pub fn qualifier(self) -> Option<Path<'a>> {
        super::child_opt(self)
    }
}

// PathExpr

#[derive(Debug, Clone)]
pub struct PathExprNode(SyntaxNode);

impl PathExprNode {
    pub fn new(ast: PathExpr) -> PathExprNode {
        let syntax = ast.syntax().owned();
        PathExprNode(syntax)
    }
    pub fn ast(&self) -> PathExpr {
        PathExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PathExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PathExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_EXPR => Some(PathExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PathExpr<'a> {
    pub fn path(self) -> Option<Path<'a>> {
        super::child_opt(self)
    }
}

// PathPat

#[derive(Debug, Clone)]
pub struct PathPatNode(SyntaxNode);

impl PathPatNode {
    pub fn new(ast: PathPat) -> PathPatNode {
        let syntax = ast.syntax().owned();
        PathPatNode(syntax)
    }
    pub fn ast(&self) -> PathPat {
        PathPat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PathPat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PathPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_PAT => Some(PathPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PathPat<'a> {}

// PathSegment

#[derive(Debug, Clone)]
pub struct PathSegmentNode(SyntaxNode);

impl PathSegmentNode {
    pub fn new(ast: PathSegment) -> PathSegmentNode {
        let syntax = ast.syntax().owned();
        PathSegmentNode(syntax)
    }
    pub fn ast(&self) -> PathSegment {
        PathSegment::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PathSegment<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PathSegment<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_SEGMENT => Some(PathSegment { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PathSegment<'a> {
    pub fn name_ref(self) -> Option<NameRef<'a>> {
        super::child_opt(self)
    }
}

// PathType

#[derive(Debug, Clone)]
pub struct PathTypeNode(SyntaxNode);

impl PathTypeNode {
    pub fn new(ast: PathType) -> PathTypeNode {
        let syntax = ast.syntax().owned();
        PathTypeNode(syntax)
    }
    pub fn ast(&self) -> PathType {
        PathType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PathType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PathType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_TYPE => Some(PathType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PathType<'a> {}

// PlaceholderPat

#[derive(Debug, Clone)]
pub struct PlaceholderPatNode(SyntaxNode);

impl PlaceholderPatNode {
    pub fn new(ast: PlaceholderPat) -> PlaceholderPatNode {
        let syntax = ast.syntax().owned();
        PlaceholderPatNode(syntax)
    }
    pub fn ast(&self) -> PlaceholderPat {
        PlaceholderPat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PlaceholderPat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PlaceholderPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PLACEHOLDER_PAT => Some(PlaceholderPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PlaceholderPat<'a> {}

// PlaceholderType

#[derive(Debug, Clone)]
pub struct PlaceholderTypeNode(SyntaxNode);

impl PlaceholderTypeNode {
    pub fn new(ast: PlaceholderType) -> PlaceholderTypeNode {
        let syntax = ast.syntax().owned();
        PlaceholderTypeNode(syntax)
    }
    pub fn ast(&self) -> PlaceholderType {
        PlaceholderType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PlaceholderType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PlaceholderType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PLACEHOLDER_TYPE => Some(PlaceholderType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PlaceholderType<'a> {}

// PointerType

#[derive(Debug, Clone)]
pub struct PointerTypeNode(SyntaxNode);

impl PointerTypeNode {
    pub fn new(ast: PointerType) -> PointerTypeNode {
        let syntax = ast.syntax().owned();
        PointerTypeNode(syntax)
    }
    pub fn ast(&self) -> PointerType {
        PointerType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PointerType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PointerType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            POINTER_TYPE => Some(PointerType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PointerType<'a> {}

// PrefixExpr

#[derive(Debug, Clone)]
pub struct PrefixExprNode(SyntaxNode);

impl PrefixExprNode {
    pub fn new(ast: PrefixExpr) -> PrefixExprNode {
        let syntax = ast.syntax().owned();
        PrefixExprNode(syntax)
    }
    pub fn ast(&self) -> PrefixExpr {
        PrefixExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct PrefixExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for PrefixExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PREFIX_EXPR => Some(PrefixExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> PrefixExpr<'a> {}

// RangeExpr

#[derive(Debug, Clone)]
pub struct RangeExprNode(SyntaxNode);

impl RangeExprNode {
    pub fn new(ast: RangeExpr) -> RangeExprNode {
        let syntax = ast.syntax().owned();
        RangeExprNode(syntax)
    }
    pub fn ast(&self) -> RangeExpr {
        RangeExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct RangeExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for RangeExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RANGE_EXPR => Some(RangeExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> RangeExpr<'a> {}

// RangePat

#[derive(Debug, Clone)]
pub struct RangePatNode(SyntaxNode);

impl RangePatNode {
    pub fn new(ast: RangePat) -> RangePatNode {
        let syntax = ast.syntax().owned();
        RangePatNode(syntax)
    }
    pub fn ast(&self) -> RangePat {
        RangePat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct RangePat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for RangePat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RANGE_PAT => Some(RangePat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> RangePat<'a> {}

// RefExpr

#[derive(Debug, Clone)]
pub struct RefExprNode(SyntaxNode);

impl RefExprNode {
    pub fn new(ast: RefExpr) -> RefExprNode {
        let syntax = ast.syntax().owned();
        RefExprNode(syntax)
    }
    pub fn ast(&self) -> RefExpr {
        RefExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct RefExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for RefExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REF_EXPR => Some(RefExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> RefExpr<'a> {}

// RefPat

#[derive(Debug, Clone)]
pub struct RefPatNode(SyntaxNode);

impl RefPatNode {
    pub fn new(ast: RefPat) -> RefPatNode {
        let syntax = ast.syntax().owned();
        RefPatNode(syntax)
    }
    pub fn ast(&self) -> RefPat {
        RefPat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct RefPat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for RefPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REF_PAT => Some(RefPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> RefPat<'a> {}

// ReferenceType

#[derive(Debug, Clone)]
pub struct ReferenceTypeNode(SyntaxNode);

impl ReferenceTypeNode {
    pub fn new(ast: ReferenceType) -> ReferenceTypeNode {
        let syntax = ast.syntax().owned();
        ReferenceTypeNode(syntax)
    }
    pub fn ast(&self) -> ReferenceType {
        ReferenceType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ReferenceType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ReferenceType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REFERENCE_TYPE => Some(ReferenceType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ReferenceType<'a> {}

// RetType

#[derive(Debug, Clone)]
pub struct RetTypeNode(SyntaxNode);

impl RetTypeNode {
    pub fn new(ast: RetType) -> RetTypeNode {
        let syntax = ast.syntax().owned();
        RetTypeNode(syntax)
    }
    pub fn ast(&self) -> RetType {
        RetType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct RetType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for RetType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RET_TYPE => Some(RetType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> RetType<'a> {}

// ReturnExpr

#[derive(Debug, Clone)]
pub struct ReturnExprNode(SyntaxNode);

impl ReturnExprNode {
    pub fn new(ast: ReturnExpr) -> ReturnExprNode {
        let syntax = ast.syntax().owned();
        ReturnExprNode(syntax)
    }
    pub fn ast(&self) -> ReturnExpr {
        ReturnExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct ReturnExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for ReturnExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RETURN_EXPR => Some(ReturnExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ReturnExpr<'a> {}

// Root

#[derive(Debug, Clone)]
pub struct RootNode(SyntaxNode);

impl RootNode {
    pub fn new(ast: Root) -> RootNode {
        let syntax = ast.syntax().owned();
        RootNode(syntax)
    }
    pub fn ast(&self) -> Root {
        Root::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Root<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Root<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ROOT => Some(Root { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::ModuleItemOwner<'a> for Root<'a> {}
impl<'a> ast::FnDefOwner<'a> for Root<'a> {}
impl<'a> Root<'a> {
    pub fn modules(self) -> impl Iterator<Item = Module<'a>> + 'a {
        super::children(self)
    }
}

// SelfParam

#[derive(Debug, Clone)]
pub struct SelfParamNode(SyntaxNode);

impl SelfParamNode {
    pub fn new(ast: SelfParam) -> SelfParamNode {
        let syntax = ast.syntax().owned();
        SelfParamNode(syntax)
    }
    pub fn ast(&self) -> SelfParam {
        SelfParam::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct SelfParam<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for SelfParam<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            SELF_PARAM => Some(SelfParam { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> SelfParam<'a> {}

// SlicePat

#[derive(Debug, Clone)]
pub struct SlicePatNode(SyntaxNode);

impl SlicePatNode {
    pub fn new(ast: SlicePat) -> SlicePatNode {
        let syntax = ast.syntax().owned();
        SlicePatNode(syntax)
    }
    pub fn ast(&self) -> SlicePat {
        SlicePat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct SlicePat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for SlicePat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            SLICE_PAT => Some(SlicePat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> SlicePat<'a> {}

// SliceType

#[derive(Debug, Clone)]
pub struct SliceTypeNode(SyntaxNode);

impl SliceTypeNode {
    pub fn new(ast: SliceType) -> SliceTypeNode {
        let syntax = ast.syntax().owned();
        SliceTypeNode(syntax)
    }
    pub fn ast(&self) -> SliceType {
        SliceType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct SliceType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for SliceType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            SLICE_TYPE => Some(SliceType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> SliceType<'a> {}

// StaticDef

#[derive(Debug, Clone)]
pub struct StaticDefNode(SyntaxNode);

impl StaticDefNode {
    pub fn new(ast: StaticDef) -> StaticDefNode {
        let syntax = ast.syntax().owned();
        StaticDefNode(syntax)
    }
    pub fn ast(&self) -> StaticDef {
        StaticDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct StaticDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for StaticDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STATIC_DEF => Some(StaticDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for StaticDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for StaticDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for StaticDef<'a> {}
impl<'a> StaticDef<'a> {}

// Stmt

#[derive(Debug, Clone)]
pub struct StmtNode(SyntaxNode);

impl StmtNode {
    pub fn new(ast: Stmt) -> StmtNode {
        let syntax = ast.syntax().owned();
        StmtNode(syntax)
    }
    pub fn ast(&self) -> Stmt {
        Stmt::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub enum Stmt<'a> {
    ExprStmt(ExprStmt<'a>),
    LetStmt(LetStmt<'a>),
}

impl<'a> AstNode<'a> for Stmt<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            EXPR_STMT => Some(Stmt::ExprStmt(ExprStmt { syntax })),
            LET_STMT => Some(Stmt::LetStmt(LetStmt { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            Stmt::ExprStmt(inner) => inner.syntax(),
            Stmt::LetStmt(inner) => inner.syntax(),
        }
    }
}

impl<'a> Stmt<'a> {}

// StructDef

#[derive(Debug, Clone)]
pub struct StructDefNode(SyntaxNode);

impl StructDefNode {
    pub fn new(ast: StructDef) -> StructDefNode {
        let syntax = ast.syntax().owned();
        StructDefNode(syntax)
    }
    pub fn ast(&self) -> StructDef {
        StructDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct StructDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for StructDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_DEF => Some(StructDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for StructDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for StructDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for StructDef<'a> {}
impl<'a> StructDef<'a> {
    pub fn fields(self) -> impl Iterator<Item = NamedFieldDef<'a>> + 'a {
        super::children(self)
    }
}

// StructLit

#[derive(Debug, Clone)]
pub struct StructLitNode(SyntaxNode);

impl StructLitNode {
    pub fn new(ast: StructLit) -> StructLitNode {
        let syntax = ast.syntax().owned();
        StructLitNode(syntax)
    }
    pub fn ast(&self) -> StructLit {
        StructLit::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct StructLit<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for StructLit<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_LIT => Some(StructLit { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> StructLit<'a> {}

// StructPat

#[derive(Debug, Clone)]
pub struct StructPatNode(SyntaxNode);

impl StructPatNode {
    pub fn new(ast: StructPat) -> StructPatNode {
        let syntax = ast.syntax().owned();
        StructPatNode(syntax)
    }
    pub fn ast(&self) -> StructPat {
        StructPat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct StructPat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for StructPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_PAT => Some(StructPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> StructPat<'a> {}

// TokenTree

#[derive(Debug, Clone)]
pub struct TokenTreeNode(SyntaxNode);

impl TokenTreeNode {
    pub fn new(ast: TokenTree) -> TokenTreeNode {
        let syntax = ast.syntax().owned();
        TokenTreeNode(syntax)
    }
    pub fn ast(&self) -> TokenTree {
        TokenTree::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TokenTree<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TokenTree<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TOKEN_TREE => Some(TokenTree { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> TokenTree<'a> {}

// TraitDef

#[derive(Debug, Clone)]
pub struct TraitDefNode(SyntaxNode);

impl TraitDefNode {
    pub fn new(ast: TraitDef) -> TraitDefNode {
        let syntax = ast.syntax().owned();
        TraitDefNode(syntax)
    }
    pub fn ast(&self) -> TraitDef {
        TraitDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TraitDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TraitDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TRAIT_DEF => Some(TraitDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for TraitDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for TraitDef<'a> {}
impl<'a> TraitDef<'a> {}

// TryExpr

#[derive(Debug, Clone)]
pub struct TryExprNode(SyntaxNode);

impl TryExprNode {
    pub fn new(ast: TryExpr) -> TryExprNode {
        let syntax = ast.syntax().owned();
        TryExprNode(syntax)
    }
    pub fn ast(&self) -> TryExpr {
        TryExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TryExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TryExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TRY_EXPR => Some(TryExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> TryExpr<'a> {}

// TupleExpr

#[derive(Debug, Clone)]
pub struct TupleExprNode(SyntaxNode);

impl TupleExprNode {
    pub fn new(ast: TupleExpr) -> TupleExprNode {
        let syntax = ast.syntax().owned();
        TupleExprNode(syntax)
    }
    pub fn ast(&self) -> TupleExpr {
        TupleExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TupleExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TupleExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_EXPR => Some(TupleExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> TupleExpr<'a> {}

// TuplePat

#[derive(Debug, Clone)]
pub struct TuplePatNode(SyntaxNode);

impl TuplePatNode {
    pub fn new(ast: TuplePat) -> TuplePatNode {
        let syntax = ast.syntax().owned();
        TuplePatNode(syntax)
    }
    pub fn ast(&self) -> TuplePat {
        TuplePat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TuplePat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TuplePat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_PAT => Some(TuplePat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> TuplePat<'a> {}

// TupleStructPat

#[derive(Debug, Clone)]
pub struct TupleStructPatNode(SyntaxNode);

impl TupleStructPatNode {
    pub fn new(ast: TupleStructPat) -> TupleStructPatNode {
        let syntax = ast.syntax().owned();
        TupleStructPatNode(syntax)
    }
    pub fn ast(&self) -> TupleStructPat {
        TupleStructPat::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TupleStructPat<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TupleStructPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_STRUCT_PAT => Some(TupleStructPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> TupleStructPat<'a> {}

// TupleType

#[derive(Debug, Clone)]
pub struct TupleTypeNode(SyntaxNode);

impl TupleTypeNode {
    pub fn new(ast: TupleType) -> TupleTypeNode {
        let syntax = ast.syntax().owned();
        TupleTypeNode(syntax)
    }
    pub fn ast(&self) -> TupleType {
        TupleType::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TupleType<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TupleType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_TYPE => Some(TupleType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> TupleType<'a> {}

// TypeDef

#[derive(Debug, Clone)]
pub struct TypeDefNode(SyntaxNode);

impl TypeDefNode {
    pub fn new(ast: TypeDef) -> TypeDefNode {
        let syntax = ast.syntax().owned();
        TypeDefNode(syntax)
    }
    pub fn ast(&self) -> TypeDef {
        TypeDef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TypeDef<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TypeDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TYPE_DEF => Some(TypeDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for TypeDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for TypeDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for TypeDef<'a> {}
impl<'a> TypeDef<'a> {}

// TypeParam

#[derive(Debug, Clone)]
pub struct TypeParamNode(SyntaxNode);

impl TypeParamNode {
    pub fn new(ast: TypeParam) -> TypeParamNode {
        let syntax = ast.syntax().owned();
        TypeParamNode(syntax)
    }
    pub fn ast(&self) -> TypeParam {
        TypeParam::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TypeParam<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TypeParam<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TYPE_PARAM => Some(TypeParam { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::NameOwner<'a> for TypeParam<'a> {}
impl<'a> TypeParam<'a> {}

// TypeParamList

#[derive(Debug, Clone)]
pub struct TypeParamListNode(SyntaxNode);

impl TypeParamListNode {
    pub fn new(ast: TypeParamList) -> TypeParamListNode {
        let syntax = ast.syntax().owned();
        TypeParamListNode(syntax)
    }
    pub fn ast(&self) -> TypeParamList {
        TypeParamList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct TypeParamList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for TypeParamList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TYPE_PARAM_LIST => Some(TypeParamList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> TypeParamList<'a> {
    pub fn type_params(self) -> impl Iterator<Item = TypeParam<'a>> + 'a {
        super::children(self)
    }

    pub fn lifetime_params(self) -> impl Iterator<Item = LifetimeParam<'a>> + 'a {
        super::children(self)
    }
}

// TypeRef

#[derive(Debug, Clone)]
pub struct TypeRefNode(SyntaxNode);

impl TypeRefNode {
    pub fn new(ast: TypeRef) -> TypeRefNode {
        let syntax = ast.syntax().owned();
        TypeRefNode(syntax)
    }
    pub fn ast(&self) -> TypeRef {
        TypeRef::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub enum TypeRef<'a> {
    ParenType(ParenType<'a>),
    TupleType(TupleType<'a>),
    NeverType(NeverType<'a>),
    PathType(PathType<'a>),
    PointerType(PointerType<'a>),
    ArrayType(ArrayType<'a>),
    SliceType(SliceType<'a>),
    ReferenceType(ReferenceType<'a>),
    PlaceholderType(PlaceholderType<'a>),
    FnPointerType(FnPointerType<'a>),
    ForType(ForType<'a>),
    ImplTraitType(ImplTraitType<'a>),
    DynTraitType(DynTraitType<'a>),
}

impl<'a> AstNode<'a> for TypeRef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PAREN_TYPE => Some(TypeRef::ParenType(ParenType { syntax })),
            TUPLE_TYPE => Some(TypeRef::TupleType(TupleType { syntax })),
            NEVER_TYPE => Some(TypeRef::NeverType(NeverType { syntax })),
            PATH_TYPE => Some(TypeRef::PathType(PathType { syntax })),
            POINTER_TYPE => Some(TypeRef::PointerType(PointerType { syntax })),
            ARRAY_TYPE => Some(TypeRef::ArrayType(ArrayType { syntax })),
            SLICE_TYPE => Some(TypeRef::SliceType(SliceType { syntax })),
            REFERENCE_TYPE => Some(TypeRef::ReferenceType(ReferenceType { syntax })),
            PLACEHOLDER_TYPE => Some(TypeRef::PlaceholderType(PlaceholderType { syntax })),
            FN_POINTER_TYPE => Some(TypeRef::FnPointerType(FnPointerType { syntax })),
            FOR_TYPE => Some(TypeRef::ForType(ForType { syntax })),
            IMPL_TRAIT_TYPE => Some(TypeRef::ImplTraitType(ImplTraitType { syntax })),
            DYN_TRAIT_TYPE => Some(TypeRef::DynTraitType(DynTraitType { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            TypeRef::ParenType(inner) => inner.syntax(),
            TypeRef::TupleType(inner) => inner.syntax(),
            TypeRef::NeverType(inner) => inner.syntax(),
            TypeRef::PathType(inner) => inner.syntax(),
            TypeRef::PointerType(inner) => inner.syntax(),
            TypeRef::ArrayType(inner) => inner.syntax(),
            TypeRef::SliceType(inner) => inner.syntax(),
            TypeRef::ReferenceType(inner) => inner.syntax(),
            TypeRef::PlaceholderType(inner) => inner.syntax(),
            TypeRef::FnPointerType(inner) => inner.syntax(),
            TypeRef::ForType(inner) => inner.syntax(),
            TypeRef::ImplTraitType(inner) => inner.syntax(),
            TypeRef::DynTraitType(inner) => inner.syntax(),
        }
    }
}

impl<'a> TypeRef<'a> {}

// UseItem

#[derive(Debug, Clone)]
pub struct UseItemNode(SyntaxNode);

impl UseItemNode {
    pub fn new(ast: UseItem) -> UseItemNode {
        let syntax = ast.syntax().owned();
        UseItemNode(syntax)
    }
    pub fn ast(&self) -> UseItem {
        UseItem::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct UseItem<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for UseItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            USE_ITEM => Some(UseItem { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> UseItem<'a> {
    pub fn use_tree(self) -> Option<UseTree<'a>> {
        super::child_opt(self)
    }
}

// UseTree

#[derive(Debug, Clone)]
pub struct UseTreeNode(SyntaxNode);

impl UseTreeNode {
    pub fn new(ast: UseTree) -> UseTreeNode {
        let syntax = ast.syntax().owned();
        UseTreeNode(syntax)
    }
    pub fn ast(&self) -> UseTree {
        UseTree::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct UseTree<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for UseTree<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            USE_TREE => Some(UseTree { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> UseTree<'a> {
    pub fn path(self) -> Option<Path<'a>> {
        super::child_opt(self)
    }

    pub fn use_tree_list(self) -> Option<UseTreeList<'a>> {
        super::child_opt(self)
    }
}

// UseTreeList

#[derive(Debug, Clone)]
pub struct UseTreeListNode(SyntaxNode);

impl UseTreeListNode {
    pub fn new(ast: UseTreeList) -> UseTreeListNode {
        let syntax = ast.syntax().owned();
        UseTreeListNode(syntax)
    }
    pub fn ast(&self) -> UseTreeList {
        UseTreeList::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct UseTreeList<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for UseTreeList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            USE_TREE_LIST => Some(UseTreeList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> UseTreeList<'a> {
    pub fn use_trees(self) -> impl Iterator<Item = UseTree<'a>> + 'a {
        super::children(self)
    }
}

// WhereClause

#[derive(Debug, Clone)]
pub struct WhereClauseNode(SyntaxNode);

impl WhereClauseNode {
    pub fn new(ast: WhereClause) -> WhereClauseNode {
        let syntax = ast.syntax().owned();
        WhereClauseNode(syntax)
    }
    pub fn ast(&self) -> WhereClause {
        WhereClause::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct WhereClause<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for WhereClause<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            WHERE_CLAUSE => Some(WhereClause { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> WhereClause<'a> {}

// WhileExpr

#[derive(Debug, Clone)]
pub struct WhileExprNode(SyntaxNode);

impl WhileExprNode {
    pub fn new(ast: WhileExpr) -> WhileExprNode {
        let syntax = ast.syntax().owned();
        WhileExprNode(syntax)
    }
    pub fn ast(&self) -> WhileExpr {
        WhileExpr::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct WhileExpr<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for WhileExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            WHILE_EXPR => Some(WhileExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> ast::LoopBodyOwner<'a> for WhileExpr<'a> {}
impl<'a> WhileExpr<'a> {
    pub fn condition(self) -> Option<Condition<'a>> {
        super::child_opt(self)
    }
}

// Whitespace

#[derive(Debug, Clone)]
pub struct WhitespaceNode(SyntaxNode);

impl WhitespaceNode {
    pub fn new(ast: Whitespace) -> WhitespaceNode {
        let syntax = ast.syntax().owned();
        WhitespaceNode(syntax)
    }
    pub fn ast(&self) -> Whitespace {
        Whitespace::cast(self.0.borrowed()).unwrap()
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Whitespace<'a> {
    syntax: SyntaxNodeRef<'a>,
}

impl<'a> AstNode<'a> for Whitespace<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            WHITESPACE => Some(Whitespace { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<'a> Whitespace<'a> {}

