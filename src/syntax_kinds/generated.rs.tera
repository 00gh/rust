#![allow(bad_style, missing_docs, unreachable_pub)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::SyntaxInfo;

/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum SyntaxKind {
{%- for t in tokens %}
    {{t}},
{%- endfor -%}
{% for kw in keywords %}
    {{kw | upper}}_KW,
{%- endfor -%}
{% for kw in contextual_keywords %}
    {{kw | upper}}_KW,
{%- endfor -%}
{% for node in nodes %}
    {{node}},
{%- endfor %}
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
}
use self::SyntaxKind::*;

impl SyntaxKind {
    pub(crate) fn info(self) -> &'static SyntaxInfo {
        match self {
{%- for t in tokens %}
            {{t}} => &SyntaxInfo { name: "{{t}}" },
{%- endfor -%}
{% for kw in keywords %}
            {{kw | upper}}_KW => &SyntaxInfo { name: "{{kw | upper}}_KW" },
{%- endfor -%}
{% for kw in contextual_keywords %}
            {{kw | upper}}_KW => &SyntaxInfo { name: "{{kw | upper}}_KW" },
{%- endfor -%}
{% for node in nodes %}
            {{node}} => &SyntaxInfo { name: "{{node}}" },
{%- endfor %}

            TOMBSTONE => &SyntaxInfo { name: "TOMBSTONE" },
            EOF => &SyntaxInfo { name: "EOF" },
        }
    }
    pub(crate) fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
{%- for kw in keywords %}
            "{{kw}}" => {{kw | upper}}_KW,
{%- endfor %}
            _ => return None,
        };
        Some(kw)
    }
}

