warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:7:8
   |
LL |     if (fn_ptr as *mut ()).is_null() {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value
   = note: `#[warn(useless_ptr_null_checks)]` on by default

warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:9:8
   |
LL |     if (fn_ptr as *const u8).is_null() {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value

warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:11:8
   |
LL |     if (fn_ptr as *const ()) == std::ptr::null() {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value

warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:13:8
   |
LL |     if (fn_ptr as *mut ()) == std::ptr::null_mut() {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value

warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:15:8
   |
LL |     if (fn_ptr as *const ()) == (0 as *const ()) {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value

warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:17:8
   |
LL |     if <*const _>::is_null(fn_ptr as *const ()) {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value

warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:19:8
   |
LL |     if (fn_ptr as *mut fn() as *const fn() as *const ()).is_null() {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value

warning: function pointers are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:21:8
   |
LL |     if (fn_ptr as fn() as *const ()).is_null() {}
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:25:8
   |
LL |     if (&mut 8 as *mut i32).is_null() {}
   |        ^------^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&mut i32`

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:27:8
   |
LL |     if (&8 as *const i32).is_null() {}
   |        ^--^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&i32`

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:29:8
   |
LL |     if (&8 as *const i32) == std::ptr::null() {}
   |        ^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&i32`

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:32:8
   |
LL |     if (ref_num as *const i32) == std::ptr::null() {}
   |        ^-------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&i32`

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:34:8
   |
LL |     if (b"\0" as *const u8).is_null() {}
   |        ^-----^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&[u8; 1]`

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:36:8
   |
LL |     if ("aa" as *const str).is_null() {}
   |        ^----^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&str`

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:38:8
   |
LL |     if (&[1, 2] as *const i32).is_null() {}
   |        ^-------^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&[i32; 2]`

warning: references are not nullable, so checking them for null will always return false
  --> $DIR/ptr_null_checks.rs:40:8
   |
LL |     if (&mut [1, 2] as *mut i32) == std::ptr::null_mut() {}
   |        ^-----------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expression has type `&mut [i32; 2]`

warning: 16 warnings emitted

